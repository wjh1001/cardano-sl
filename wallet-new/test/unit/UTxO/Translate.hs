module UTxO.Translate (
    -- * Monadic context for the translation from the DSL to Cardano
    Translate
  , runTranslate
  , lift
  , liftPure
  , liftMaybe
    -- * Translation context (TODO: Cleanup)
  , Context(..)
  , Actors(..)
  , Rich(..)
  , Poor(..)
  , Stakeholder(..)
  , DelegatedTo(..)
  , KeyPair(..)
  , EncKeyPair(..)
  , getContext
  , generatedActors
  , genesisBlock0
  , getLeaderForSlot
  , BlockSignInfo(..)
  , getBlockSignInfo
    -- * Uniform API to rich and poor actors
  , RegularActor(..)
  , ActorIx(..)
  , AddrIx
  , Addr
  , actorWithIx
  , actorAddr
  , resolveAddr
    -- * Interface to the verifier
  , verifyFromGenesis
  , verifyFromGenesis'
  ) where

import Universum hiding (lift)
import Control.Exception (throw)
import Control.Monad.Except (MonadError)
import Data.List ((!!))
import Formatting (bprint, build, (%))
import Serokell.Util (listJson, pairF)
import System.IO.Error (userError)
import qualified Data.HashMap.Strict as HM
import qualified Data.List.NonEmpty  as NE
import qualified Data.Map.Strict     as Map
import qualified Data.Text.Buildable

import Pos.Block.Error
import Pos.Block.Types
import Pos.Core hiding (genesisData, generatedSecrets)
import Pos.Crypto
import Pos.Txp (Utxo, utxoToAddressCoinPairs)
import Pos.Update
import Pos.Util.Chrono
import qualified Pos.Context     as Cardano
import qualified Pos.Core        as Cardano
import qualified Pos.Lrc.Genesis as Cardano

import qualified UTxO.Verify as Verify

{-------------------------------------------------------------------------------
  Testing infrastructure from cardano-sl-core

  The genesis block comes from defaultTestConf, which in turn uses
  configuration.yaml. It is specified by a 'GenesisSpec'.
-------------------------------------------------------------------------------}

import Test.Pos.Util (
    withDefConfiguration
  , withDefUpdateConfiguration
  )

{-------------------------------------------------------------------------------
  Translation context
-------------------------------------------------------------------------------}

data Translate a = Translate {
      unTranslate :: (HasConfiguration, HasUpdateConfiguration) => Either Text a
    }

instance Functor Translate where
  fmap = liftM

instance Applicative Translate where
  pure  = return
  (<*>) = ap

instance Monad Translate where
  return a = Translate $ Right a
  x >>= f  = Translate $ case unTranslate x of
                           Left err -> Left err
                           Right a  -> unTranslate (f a)

lift :: (forall m. (HasConfiguration, HasUpdateConfiguration, MonadError Text m) => m a)
     -> Translate a
lift act = Translate act

liftPure :: ((HasConfiguration, HasUpdateConfiguration) => a) -> Translate a
liftPure a = Translate (Right a)

liftMaybe :: Text -> ((HasConfiguration, HasUpdateConfiguration) => Maybe a) -> Translate a
liftMaybe err ma = Translate $ case ma of
                                 Just a  -> Right a
                                 Nothing -> Left err

runTranslate :: Translate a -> a
runTranslate (Translate act) =
   withDefConfiguration $
   withDefUpdateConfiguration $
     case act of
       Left  e -> throw (userError (show e))
       Right a -> a

{-------------------------------------------------------------------------------
  Some cardano operations lifted to 'Translate'
-------------------------------------------------------------------------------}

genesisBlock0  :: Translate GenesisBlock
genesisData    :: Translate GenesisData
genesisLeaders :: Translate SlotLeaders
genesisStakes  :: Translate StakesMap
genesisUtxo    :: Translate Utxo

genesisBlock0  = liftPure Cardano.genesisBlock0
genesisData    = liftPure Cardano.genesisData
genesisLeaders = liftPure Cardano.genesisLeaders
genesisStakes  = liftPure Cardano.genesisStakes
genesisUtxo    = liftPure (Cardano.unGenesisUtxo Cardano.genesisUtxo)

genesisBalances :: Translate [(Address, Coin)]
genesisBalances = utxoToAddressCoinPairs <$> genesisUtxo

generatedSecrets :: Translate GeneratedSecrets
generatedSecrets = liftMaybe err Cardano.generatedSecrets
  where
    err :: Text
    err = "Generated secrets unavailable"

-- | Hash of the genesis block header
--
-- NOTE: This is /not/ the same as 'genesisHash'
genesisHeaderHash :: Translate HeaderHash
genesisHeaderHash =
    liftPure $ blockHeaderHash . Left . _gbHeader $ Cardano.genesisBlock0

{-------------------------------------------------------------------------------
  Translation context

  At the moment, the translation context simply comes from the genesis block
  generated by the Cardano core, based on the configuration parameters in
  @configuration.yaml@.

  When heavy-weight delegation is enabled, 'generateGenesisData' creates three
  sets of actors, each with their own set of secret keys:

  * The 'poor' actors, with a small balance ('gsPoorSecrets')
    (these use HD addresses)
  * The 'rich' actors, with a large balance ('gsRichSecrets')
    (these do not use HD addresses)
  * The stakeholders ('gsDlgIssuersSecrets')
    (no addresses get generated for these)

  (Using the Ouroboros-neutral word "actor" intentionally to avoid confusion.)

  All addresses (for the poor and rich actors) use 'BootstrapEraDistr' as their
  stake distribution attribute; in 'bootstrapEraDistr' this is interpreted as
  a distribution over the 'gdBootStakeholders' in the genesis data, which in
  turn is derived from 'gsDlgIssuersSecrets' in 'generateGenesisData'.

  Additionally, 'generateGenesisData' generates a set of 'ProxySKHeavy' (aka
  'ProxySecretKey EpochIndex') delegating from the stakeholders (the
  'pskIssuerPk') to the rich actors (the 'pskDelegatePk'). The following excerpt
  from Section 8.2, Delegation Schema, of the Ouroboros paper is relevant here:

  > A stakeholder can transfer the right to generate blocks by creating a proxy
  > signing key that allows the delegate to sign messages of the form (st, d,
  > slj) (i.e., the format of messages signed in Protocol Ï€DPoS to authenticate
  > a block).

  So it's actually the rich actors that sign blocks on behalf of the
  stakeholders.

  The genesis UTxO computed by 'genesisUtxo', being a Utxo, is simply a set of
  unspent transaction outputs; 'genesisStakes' then uses 'utxoToStakes' to turn
  this into a 'StakeMap'. A key component of this transaction is 'txOutStake',
  which relies on 'bootstrapEtaDistr' for addresses marked 'BootstrapEraDistr'.
  Thus the 'StakesMap' computed by 'genesisStakes' will contain 'StakeholderId's
  of the stakeholders, even though (somewhat confusingly) the stakeholders are
  never actually assigned any addresses.

  Finally, 'genesisLeaders' uses 'followTheSatoshiUtxo' applied to the
  'genesisUtxo' to compute the 'SlotLeaders' (aka 'NonEmpty StakeholderId').
  Since the stake holders have delegated their signing privilege to the rich
  actors, however, it is actually the rich actors that sign the blocks. The
  mapping from the (public keys) of the stakeholders to the (public keys) of the
  rich actors is recorded in 'gdHeavyDelegation' of 'GenesisData'.

  Concretely, the generated genesis data looks something like this:

  > Context{
  >     actors:   Actors{
  >       rich:  [ R1 .. R4 ]
  >     , poor:  [ P1 .. P12 ]
  >     , stake: [ S1 .. S4 ]
  >   }
  >   , leaders:  [ S3, ... ]
  >   , stakes:   [
  >     , (S1, 11250000000000016 coin(s))
  >     , (S2, 11249999999999992 coin(s))
  >     , (S3, 11249999999999992 coin(s))
  >     , (S4, 11249999999999992 coin(s))
  >     ------------------------
  >     total: 44999999999999992
  >   ]
  >   , balances: [
  >       ... "fake AVVM" balances omitted ...
  >       ( P1_1, 37499999999166 coin(s))
  >     , ( P2_1, 37499999999166 coin(s))
  >     , ( P3_1, 37499999999166 coin(s))
  >     , ( P4_1, 37499999999166 coin(s))
  >     , ( P5_1, 37499999999166 coin(s))
  >     , ( P6_1, 37499999999166 coin(s))
  >     , ( P7_1, 37499999999166 coin(s))
  >     , ( P8_1, 37499999999166 coin(s))
  >     , ( P9_1, 37499999999166 coin(s))
  >     , (P10_1, 37499999999166 coin(s))
  >     , (P11_1, 37499999999166 coin(s))
  >     , (P12_1, 37499999999166 coin(s))
  >     , (R1, 11137499999752500 coin(s))
  >     , (R2, 11137499999752500 coin(s))
  >     , (R3, 11137499999752500 coin(s))
  >     , (R4, 11137499999752500 coin(s))
  >     ------------------------
  >     total: 44999999999999992
  >   ]
  > }

  where there is a delegation from each of the stakeholders to one of the
  rich actors (TODO: I don't understand why; see 'genesisDlg' in
  'generateGenesisData').
-------------------------------------------------------------------------------}

data Context = Context {
      tcActors   :: Actors
    , tcLeaders  :: SlotLeaders
    , tcStakes   :: StakesMap
    , tcBalances :: [(Address, Coin)]
    }

-- | Actors in the translation context
data Actors = Actors {
      actorsRich  :: Map PublicKey Rich
    , actorsPoor  :: Map PublicKey Poor
    , actorsStake :: Map StakeholderId Stakeholder
    }
  deriving (Show)

-- | A rich actor has a key and a "simple" (non-HD) address
data Rich = Rich {
      richKey  :: KeyPair
    , richAddr :: Address
    }
  deriving (Show)

-- | A poor actor gets a HD wallet, so it has a SecretKey per address
-- (current generation just creates a single address though)
--
-- NOTE: `encToSecret :: EncryptedSecretKey -> SecretKey`
data Poor = Poor {
      poorKey   :: EncKeyPair
    , poorAddrs :: [(EncKeyPair, Address)]
    }
  deriving (Show)

data Stakeholder = Stakeholder {
      stkKey :: KeyPair
    , stkDel :: DelegatedTo Rich
    }
  deriving (Show)

data DelegatedTo a = DelegatedTo {
      delTo  :: a
    , delPSK :: ProxySKHeavy
    }
  deriving (Show)

{-------------------------------------------------------------------------------
  In many cases the difference between rich and poor actors is not important
-------------------------------------------------------------------------------}

-- | Rich or poor actr, but not a stakeholder
data RegularActor = ActorRich Rich | ActorPoor Poor

-- | Index the actors by number
data ActorIx = IxRich Int | IxPoor Int

actorWithIx :: ActorIx -> Actors -> RegularActor
actorWithIx (IxRich i) Actors{..} = ActorRich $ Map.elems actorsRich !! i
actorWithIx (IxPoor i) Actors{..} = ActorPoor $ Map.elems actorsPoor !! i

-- | Address index of a regular actor
--
-- We don't track the difference between rich and poor actors at the type
-- level to make things a bit more uniform.
type AddrIx = Int

actorAddr :: AddrIx -> RegularActor -> (KeyPair, Address)
actorAddr ix (ActorRich Rich{..}) =
    if ix == 0
      then (richKey, richAddr)
      else error "actorAddr: rich actors have single address"
actorAddr ix (ActorPoor Poor{..}) =
    if ix < length poorAddrs
      then first fromEncKeyPair (poorAddrs !! ix)
      else error "actorAddr: address index out of bounds"

type Addr = (ActorIx, AddrIx)

resolveAddr :: Addr -> Actors -> (KeyPair, Address)
resolveAddr (actorIx, addrIx) = actorAddr addrIx . actorWithIx actorIx

{-------------------------------------------------------------------------------
  Block signing info
-------------------------------------------------------------------------------}

getLeaderForSlot :: SlotId -> Translate Stakeholder
getLeaderForSlot slotId = do
    Actors{..} <- generatedActors
    leader <- (NE.!! slotIx) <$> genesisLeaders
    return $ actorsStake Map.! leader
  where
    slotIx :: Int
    slotIx = fromIntegral $ getSlotIndex (siSlot slotId)

-- | Information needed to sign a block
data BlockSignInfo = BlockSignInfo {
      bsiLeader :: PublicKey    -- ^ Real slot leader
    , bsiKey    :: SecretKey    -- ^ Secret key of the actor signing it
    , bsiPSK    :: ProxySKHeavy -- ^ Prove that the actor may sign the block
    }

-- | 'BlockSignInfo' can be derived from the slot's 'Stakeholder'
blockSignInfo :: Stakeholder -> BlockSignInfo
blockSignInfo Stakeholder{..} = BlockSignInfo{..}
  where
    DelegatedTo{..} = stkDel
    Rich{..}        = delTo

    bsiLeader = kpPub stkKey
    bsiKey    = kpSec richKey
    bsiPSK    = delPSK

getBlockSignInfo :: SlotId -> Translate BlockSignInfo
getBlockSignInfo = fmap blockSignInfo . getLeaderForSlot

{-------------------------------------------------------------------------------
  Get the translation context from the genesis block
-------------------------------------------------------------------------------}

-- | Compute the translation context
--
-- TODO: We should compute this once, not on every access.
getContext :: Translate Context
getContext = do
    tcActors   <- generatedActors
    tcLeaders  <- genesisLeaders
    tcStakes   <- genesisStakes
    tcBalances <- genesisBalances
    return Context{..}

-- | Compute generated actors
--
-- TODO: Right now this will cause a re-computation of the known actors every
-- single time. We need to fix that (and possibly allow for the actors to
-- be dynamic).
generatedActors :: Translate Actors
generatedActors = do
     genData <- genesisData
     secrets <- generatedSecrets

     let actorsRich :: Map PublicKey Rich
         actorsRich = Map.fromList
                    $ map mkRich
                    $ gsRichSecrets secrets

         actorsPoor :: Map PublicKey Poor
         actorsPoor = Map.fromList
                    $ map mkPoor
                    $ gsPoorSecrets secrets

         actorsStake :: Map StakeholderId Stakeholder
         actorsStake = Map.fromList
                     $ map (mkStake (gdHeavyDelegation genData) actorsRich)
                     $ gsDlgIssuersSecrets secrets

     return Actors{..}
  where
    -- TODO: This mapping from the secret keys to the corresponding addresses
    -- is already present in generateGenesisData , but it is not returned.
    -- I see no choice currently but to recompute it. This is unfortunate
    -- because it means that when 'generateGenesisData' changes, we'll be
    -- out of sync here. Also, we're assuming here that 'tboUseHDAddresses'
    -- is true ('useHDAddresses' must be set to true in the config yaml file).

    mkRich :: RichSecrets -> (PublicKey, Rich)
    mkRich RichSecrets{..} =
        (kpPub richKey, Rich {..})
      where
        richKey :: KeyPair
        richKey = keyPair rsPrimaryKey

        richAddr :: Address
        richAddr = makePubKeyAddressBoot (toPublic rsPrimaryKey)

    mkPoor :: EncryptedSecretKey -> (PublicKey, Poor)
    mkPoor poorSec =
        (ekpPub poorKey, Poor {..})
      where
        poorKey :: EncKeyPair
        poorKey = encKeyPair poorSec

        poorAddrs :: [(EncKeyPair, Address)]
        poorAddrs = [ case deriveFirstHDAddress
                             (IsBootstrapEraAddr True)
                             emptyPassphrase
                             poorSec of
                        Nothing          -> error "impossible"
                        Just (addr, key) -> (encKeyPair key, addr)
                    ]

    mkStake :: GenesisDelegation
            -> Map PublicKey Rich
            -> SecretKey
            -> (StakeholderId, Stakeholder)
    mkStake del actorsRich stkSec =
        (kpHash stkKey, Stakeholder{..})
      where
        stkKey :: KeyPair
        stkKey = keyPair stkSec

        stkDel :: DelegatedTo Rich
        stkDel = DelegatedTo{..}

        delTo :: Rich
        delTo = Map.findWithDefault
                     (error ("generatedActors: delegate not found"))
                     (pskDelegatePk delPSK)
                     actorsRich

        delPSK :: ProxySKHeavy
        delPSK = HM.lookupDefault
                   (error ("generatedActors: issuer not found"))
                   (kpHash stkKey)
                   (unGenesisDelegation del)

{-------------------------------------------------------------------------------
  Convenience function to verify blocks, starting from the genesis
-------------------------------------------------------------------------------}

verifyFromGenesis
  :: OldestFirst NE Block
  -> Translate (Either VerifyBlocksException (OldestFirst NE Undo))
verifyFromGenesis blocks = do
    tip     <- genesisHeaderHash
    leaders <- genesisLeaders
    utxo    <- genesisUtxo
    let currentSlot = Nothing
    liftPure $ Verify.verify utxo $
      Verify.verifyBlocksPrefix
        tip
        currentSlot
        leaders
        (OldestFirst []) -- TODO: LastBlkSlots. Unsure about the required value or its effect
        blocks

verifyFromGenesis'
  :: OldestFirst NE Block
  -> Translate (Either VerifyBlocksException ())
verifyFromGenesis' = fmap (fmap (const ())) . verifyFromGenesis

{-------------------------------------------------------------------------------
  Secret/public key pair

  We can easily derive the public key from the secret key but it's convenient
  (primarily for pretty-printing debugging) to have both available.
-------------------------------------------------------------------------------}

data KeyPair = KeyPair {
      kpSec  :: SecretKey
    , kpPub  :: PublicKey
    , kpHash :: AddressHash PublicKey
    }
  deriving (Show)

data EncKeyPair = EncKeyPair {
      ekpEnc  :: EncryptedSecretKey
    , ekpSec  :: SecretKey
    , ekpPub  :: PublicKey
    , ekpHash :: AddressHash PublicKey
    }
  deriving (Show)

keyPair :: SecretKey -> KeyPair
keyPair kpSec = KeyPair {..}
  where
    kpPub  = toPublic    kpSec
    kpHash = addressHash kpPub

encKeyPair :: EncryptedSecretKey -> EncKeyPair
encKeyPair ekpEnc = EncKeyPair {..}
  where
    ekpSec  = encToSecret ekpEnc
    ekpPub  = encToPublic ekpEnc
    ekpHash = addressHash ekpPub

fromEncKeyPair :: EncKeyPair -> KeyPair
fromEncKeyPair EncKeyPair{..} = KeyPair{..}
  where
    kpSec  = ekpSec
    kpPub  = ekpPub
    kpHash = ekpHash

{-------------------------------------------------------------------------------
  Pretty-printing
-------------------------------------------------------------------------------}

instance Buildable Rich where
  build Rich{..} = bprint
      ( "Rich"
      % "{ key:  " % build
      % ", addr: " % build
      % "}"
      )
      richKey
      richAddr

instance Buildable Poor where
  build Poor{..} = bprint
      ( "Poor"
      % "{ key:   " % build
      % ", addrs: " % listJson
      % "}"
      )
      poorKey
      (map (bprint pairF) poorAddrs)

instance Buildable Stakeholder where
  build Stakeholder{..} = bprint
      ( "Stakeholder"
      % "{ key: " % build
      % ", del: " % build
      % "}"
      )
      stkKey
      stkDel

instance Buildable a => Buildable (DelegatedTo a) where
  build DelegatedTo{..} = bprint
      ( "DelegatedTo"
      % "{ to:  " % build
      % ", psk: " % build
      % "}"
      )
      delTo
      delPSK

instance Buildable Actors where
  build Actors{..} = bprint
      ( "Actors"
      % "{ rich:  " % listJson
      % ", poor:  " % listJson
      % ", stake: " % listJson
      % "}"
      )
      (Map.elems actorsRich)
      (Map.elems actorsPoor)
      (Map.elems actorsStake)

instance Buildable Context where
  build Context{..} = bprint
      ( "Context"
      % "{ actors:   " % build
      % ", leaders:  " % listJson
      % ", stakes:   " % listJson
      % ", balances: " % listJson
      % "}"
      )
      tcActors
      tcLeaders
      (map (bprint pairF) (HM.toList tcStakes))
      (map (bprint pairF) tcBalances)

instance Buildable KeyPair where
  build KeyPair{..} = bprint
      ( "KeyPair"
      % "{ sec:  " % build
      % ", pub:  " % build
      % ", hash: " % build
      % "}"
      )
      kpSec
      kpPub
      kpHash

instance Buildable EncKeyPair where
  build EncKeyPair{..} = bprint
      ( "EncKeyPair"
      % "{ sec:  " % build
      % ", pub:  " % build
      % ", hash: " % build
      % "}"
      )
      ekpSec
      ekpPub
      ekpHash
